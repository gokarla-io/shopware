<?php

declare(strict_types=1);

namespace Karla\Delivery\Service;

use Psr\Log\LoggerInterface;
use Shopware\Core\System\SystemConfig\SystemConfigService;
use Symfony\Contracts\HttpClient\HttpClientInterface;

/**
 * Service for managing webhooks with Karla API.
 */
class WebhookService
{
    /**
     * @codeCoverageIgnore
     * Constructor with dependency injection using property promotion.
     */
    public function __construct(
        private readonly SystemConfigService $systemConfigService,
        private readonly HttpClientInterface $httpClient,
        private readonly LoggerInterface $logger,
    ) {
    }

    /**
     * Generate a unique webhook URL for this Shopware instance.
     *
     * The shopwareWebhookId is a random identifier we generate to create a unique
     * endpoint URL. This is NOT the Karla webhook UUID (which comes from Karla API),
     * nor the Karla shop slug. It's simply a unique path segment for our endpoint.
     */
    public function generateWebhookUrl(string $baseUrl): string
    {
        // Ensure HTTPS for security (webhooks should never use HTTP)
        $baseUrl = preg_replace('/^http:\/\//i', 'https://', $baseUrl);

        // Generate random 32-character hex string as Shopware webhook identifier
        $shopwareWebhookId = bin2hex(random_bytes(16));

        return rtrim($baseUrl, '/') . '/api/karla/webhooks/' . $shopwareWebhookId;
    }

    /**
     * Create a new webhook in Karla API.
     *
     * Karla will generate and return both the webhook UUID and secret.
     *
     * @param array<string> $enabledEvents
     *
     * @return array{uuid: string, secret: string} The webhook UUID and secret from Karla API
     *
     * @throws \RuntimeException
     */
    public function createWebhook(string $url, array $enabledEvents): array
    {
        $config = $this->getRequiredConfig();
        $debugMode = $this->systemConfigService->get('KarlaDelivery.config.debugMode');

        if ($debugMode) {
            $this->logger->debug('Creating webhook in Karla API', [
                'url' => $url,
                'enabled_events' => $enabledEvents,
                'api_url' => $config['apiUrl'],
                'shop_slug' => $config['shopSlug'],
            ]);
        }

        try {
            $requestUrl = $config['apiUrl'] . '/v1/shops/' . $config['shopSlug'] . '/webhooks';

            if ($debugMode) {
                $this->logger->debug('Sending POST request to Karla API', [
                    'request_url' => $requestUrl,
                    'request_method' => 'POST',
                ]);
            }

            $response = $this->httpClient->request(
                'POST',
                $requestUrl,
                [
                    'auth_basic' => [$config['apiUsername'], $config['apiKey']],
                    'json' => [
                        'url' => $url,
                        'enabled_events' => $enabledEvents,
                        // Note: secret is NOT sent - Karla generates it
                    ],
                ],
            );

            $statusCode = $response->getStatusCode();
            $data = $response->toArray();

            if ($debugMode) {
                $this->logger->debug('Received response from Karla API', [
                    'component' => 'webhook.api',
                    'status_code' => $statusCode,
                    'webhook_uuid' => $data['uuid'] ?? null,
                    'webhook_secret' => $data['secret'] ?? null,
                    'response_data' => $data,
                ]);
            }

            // Return both UUID and secret generated by Karla
            return [
                'uuid' => $data['uuid'],
                'secret' => $data['secret'],
            ];
        } catch (\Exception $e) {
            $this->logger->error('Failed to create webhook', [
                'component' => 'webhook.api',
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'url' => $url,
            ]);

            throw new \RuntimeException('Failed to create webhook: ' . $e->getMessage(), 0, $e);
        }
    }

    /**
     * Update an existing webhook in Karla API.
     *
     * Note: We don't update the secret - it's managed by Karla.
     *
     * @param array<string> $enabledEvents
     *
     * @throws \RuntimeException
     */
    public function updateWebhook(string $webhookId, string $url, array $enabledEvents): void
    {
        $config = $this->getRequiredConfig();
        $debugMode = $this->systemConfigService->get('KarlaDelivery.config.debugMode');

        if ($debugMode) {
            $this->logger->debug('Updating webhook in Karla API', [
                'webhook_id' => $webhookId,
                'url' => $url,
                'enabled_events' => $enabledEvents,
                'api_url' => $config['apiUrl'],
                'shop_slug' => $config['shopSlug'],
            ]);
        }

        try {
            $requestUrl = $config['apiUrl'] . '/v1/shops/' . $config['shopSlug'] . '/webhooks/' . $webhookId;

            if ($debugMode) {
                $this->logger->debug('Sending PATCH request to Karla API', [
                    'request_url' => $requestUrl,
                    'request_method' => 'PATCH',
                ]);
            }

            $response = $this->httpClient->request(
                'PATCH',
                $requestUrl,
                [
                    'auth_basic' => [$config['apiUsername'], $config['apiKey']],
                    'json' => [
                        'url' => $url,
                        'enabled_events' => $enabledEvents,
                        // Note: secret is NOT sent - it's managed by Karla
                    ],
                ],
            );

            if ($debugMode) {
                $statusCode = $response->getStatusCode();
                $this->logger->debug('Received response from Karla API', [
                    'status_code' => $statusCode,
                    'webhook_id' => $webhookId,
                ]);
            }
        } catch (\Exception $e) {
            $this->logger->error('Failed to update webhook', [
                'component' => 'webhook.api',
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'webhookId' => $webhookId,
                'url' => $url,
            ]);

            throw new \RuntimeException('Failed to update webhook: ' . $e->getMessage(), 0, $e);
        }
    }

    /**
     * Delete a webhook from Karla API.
     *
     * @throws \RuntimeException
     */
    public function deleteWebhook(string $webhookId): void
    {
        $config = $this->getRequiredConfig();
        $debugMode = $this->systemConfigService->get('KarlaDelivery.config.debugMode');

        if ($debugMode) {
            $this->logger->debug('Deleting webhook in Karla API', [
                'webhook_id' => $webhookId,
                'api_url' => $config['apiUrl'],
                'shop_slug' => $config['shopSlug'],
            ]);
        }

        try {
            $requestUrl = $config['apiUrl'] . '/v1/shops/' . $config['shopSlug'] . '/webhooks/' . $webhookId;

            if ($debugMode) {
                $this->logger->debug('Sending DELETE request to Karla API', [
                    'request_url' => $requestUrl,
                    'request_method' => 'DELETE',
                ]);
            }

            $response = $this->httpClient->request(
                'DELETE',
                $requestUrl,
                [
                    'auth_basic' => [$config['apiUsername'], $config['apiKey']],
                ],
            );

            if ($debugMode) {
                $statusCode = $response->getStatusCode();
                $this->logger->debug('Received response from Karla API', [
                    'status_code' => $statusCode,
                    'webhook_id' => $webhookId,
                ]);
            }
        } catch (\Exception $e) {
            $this->logger->error('Failed to delete webhook', [
                'component' => 'webhook.api',
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'webhookId' => $webhookId,
            ]);

            throw new \RuntimeException('Failed to delete webhook: ' . $e->getMessage(), 0, $e);
        }
    }

    /**
     * Get required configuration values.
     *
     * @codeCoverageIgnore
     * This private method is implicitly tested through all public webhook management methods.
     *
     * @return array{shopSlug: string, apiUsername: string, apiKey: string, apiUrl: string}
     *
     * @throws \RuntimeException
     */
    private function getRequiredConfig(): array
    {
        $shopSlug = $this->systemConfigService->get('KarlaDelivery.config.shopSlug');
        $apiUsername = $this->systemConfigService->get('KarlaDelivery.config.apiUsername');
        $apiKey = $this->systemConfigService->get('KarlaDelivery.config.apiKey');
        $apiUrl = $this->systemConfigService->get('KarlaDelivery.config.apiUrl');

        if (! $shopSlug || ! $apiUsername || ! $apiKey || ! $apiUrl) {
            $operation = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2)[1]['function'] ?? 'unknown';
            $this->logger->error('Missing required configuration for webhook ' . $operation);

            throw new \RuntimeException('Missing required configuration: shopSlug, apiUsername, apiKey, or apiUrl');
        }

        return [
            'shopSlug' => $shopSlug,
            'apiUsername' => $apiUsername,
            'apiKey' => $apiKey,
            'apiUrl' => $apiUrl,
        ];
    }
}
